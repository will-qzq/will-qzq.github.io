{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Ubuntu一些问题解决办法","slug":"Ubuntu一些问题解决办法","date":"2019-12-12T12:47:18.000Z","updated":"2019-12-12T12:54:24.958Z","comments":true,"path":"2019/12/12/Ubuntu一些问题解决办法/","link":"","permalink":"http://yoursite.com/2019/12/12/Ubuntu%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","excerpt":"","text":"#Ubuntu一些问题解决链接##关于无线联网总是显示连接断开 使用NAT连接 然后在服务中将有VM的全部启动链接：https://blog.csdn.net/qq_36045385/article/details/81506540##关于无法连接U盘问题大部分U盘首先在设置下设置共享如果显示驱动错误需要更新驱动，但要注意的是，驱动精灵和其他的一些驱动软件是检测不出来的，所以必须使用驱动人生。链接：https://blog.csdn.net/Behold1942/article/details/80065543","categories":[],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"}]},{"title":"水下机器人初始安装","slug":"水下机器人初始安装","date":"2019-12-07T14:34:02.000Z","updated":"2019-12-07T14:49:27.202Z","comments":true,"path":"2019/12/07/水下机器人初始安装/","link":"","permalink":"http://yoursite.com/2019/12/07/%E6%B0%B4%E4%B8%8B%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%88%9D%E5%A7%8B%E5%AE%89%E8%A3%85/","excerpt":"","text":"水下机器人相关安装1、安装QGroundControl地面站软件 window ios Linux","categories":[],"tags":[{"name":"水下机器人","slug":"水下机器人","permalink":"http://yoursite.com/tags/%E6%B0%B4%E4%B8%8B%E6%9C%BA%E5%99%A8%E4%BA%BA/"}]},{"title":"树莓派安全操作","slug":"树莓派安全操作","date":"2019-12-07T13:58:01.000Z","updated":"2019-12-07T14:29:34.868Z","comments":true,"path":"2019/12/07/树莓派安全操作/","link":"","permalink":"http://yoursite.com/2019/12/07/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C/","excerpt":"","text":"#树莓派操作安全##树莓派是一个集成度非常高的产品使用时不要用手去触碰芯片中间的位置，摸接口的两边如下图。因为手上带有静电，很容易把IO击穿，或损坏板子。如果放在桌面上，桌面上不能有金属制品。","categories":[],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"http://yoursite.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"}]},{"title":"Mavlink通信协议","slug":"Mavlink通信协议","date":"2019-11-25T15:41:07.385Z","updated":"2019-11-25T15:42:41.478Z","comments":true,"path":"2019/11/25/Mavlink通信协议/","link":"","permalink":"http://yoursite.com/2019/11/25/Mavlink%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"##Mavlink通信协议，中文","categories":[],"tags":[]},{"title":"顺序表图书管理系统","slug":"顺序表图书管理系统","date":"2019-11-22T17:13:58.932Z","updated":"2019-11-22T17:04:14.611Z","comments":true,"path":"2019/11/23/顺序表图书管理系统/","link":"","permalink":"http://yoursite.com/2019/11/23/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"#顺序表图书管理系统 #include&lt;iostream&gt; #include&lt;string.h&gt; #include&lt;stdlib.h&gt; #include&lt;stdio.h&gt; #include&lt;conio.h&gt; #include&lt;time.h&gt; #define N 1000000 using namespace std; int count_num=0; struct book //书的结构体 { unsigned long long int key;//书号 char name[30]; //书名 char author[20];//作者 unsigned int stock; //现存量 unsigned int total;//总库存量 } b[N];//存储书的数组 typedef struct node { int keynum;//结点关键值 struct node *next; //指向下一个结点指针 }node; int count=0; node* create(int x) { node *p,*pre,*head; head=new node; head-&gt;next=NULL; pre=head; for(int i=1;i&lt;x;i++) { p=new node; p-&gt;keynum=i; p-&gt;next=NULL; pre-&gt;next=p; pre=p; } return head; } int Search(int x) //在一个结点中查找元素，返回结点位置 { for(int i=0;i&lt;count_num;i++) { if(b[i].key==x) return 1; return 0; } } void inset(node* head,int pos) { int i; node* p=head; for(i=0;i&lt;pos-1;i++) { p=p-&gt;next; } node* q=new node; q-&gt;keynum=i; q-&gt;next=p-&gt;next; p-&gt;next=q; } void Copy(book &amp;b,book k) //复制一个结点 { b.key=k.key; strcpy(b.name,k.name); strcpy(b.author,k.author); b.stock=k.stock; b.total=k.total; } void save() //保存文件 { FILE *fp; if((fp=fopen(&quot;com.txt&quot;,&quot;wb&quot;))==NULL) { cout&lt;&lt;&quot;创建文件失败！&quot;&lt;&lt;endl; getch(); return; } for(int i=1;i&lt;=2;i++) { fprintf(fp,&quot;%d %s %s %d %d \\n&quot;,b[i].key,b[i].name,b[i].author,b[i].stock,b[i].total); } fclose(fp); } void read() //读取文件 { FILE *fp,fp1; if((fp=fopen(&quot;com.txt&quot;,&quot;rb&quot;))==NULL) { cout&lt;&lt;&quot;读取文件失败！&quot;&lt;&lt;endl; getchar(); return; } for(int i=1;;i++) { count_num++; if(fscanf(fp,&quot;%d%s%s%d%d&quot;,&amp;b[i].key,&amp;b[i].name,&amp;b[i].author,&amp;b[i].stock,&amp;b[i].total)==EOF) { break; } } fclose(fp); } void del(node* head,int x) { node* p=head-&gt;next; node* pre=head; while(p!=NULL) { if(p-&gt;keynum==x) { pre-&gt;next=p-&gt;next; delete(p); p=pre-&gt;next; } else { pre=p; p=p-&gt;next; } } } void Shownode(int x) //输出书的信息 { for(int i=0;i&lt;=x;i++) { cout&lt;&lt;&quot;书号&quot;&lt;&lt;b[i].key&lt;&lt;&quot;,书名为《&quot;&lt;&lt;b[i].name&lt;&lt;&quot;》，作者为&quot;&lt;&lt;b[i].author&lt;&lt;&quot;,现存&quot;&lt;&lt;b[i].stock&lt;&lt;&quot;本，总量&quot;&lt;&lt;b[i].total&lt;&lt;&quot;本。&quot;&lt;&lt;endl; } } void InBookMess() //输入书的信息 { count_num++; //cout&lt;&lt;&quot;请输入书号：&quot;;cin&gt;&gt;bk.key; cout&lt;&lt;&quot;请输入书名：&quot;;cin&gt;&gt;b[count_num].name; cout&lt;&lt;&quot;请输入作者：&quot;;cin&gt;&gt;b[count_num].author; cout&lt;&lt;&quot;请输入总量：&quot;;cin&gt;&gt;b[count_num].total; b[count_num].stock=b[count_num].total; b[count_num].key=count_num; cout&lt;&lt;&quot;书号&quot;&lt;&lt;b[count_num].key&lt;&lt;&quot;,书名为《&quot;&lt;&lt;b[count_num].name&lt;&lt;&quot;》，作者为&quot;&lt;&lt;b[count_num].author&lt;&lt;&quot;,现存&quot;&lt;&lt;b[count_num].stock&lt;&lt;&quot;本，总量&quot;&lt;&lt;b[count_num].total&lt;&lt;&quot;本。&quot;&lt;&lt;endl; } int BorrowBook(int k) //借书 { int r=0; r=Search(k); if(r==0) { cout&lt;&lt;&quot;你要借阅的书不存在。&quot;&lt;&lt;endl; return 0; } else { cout&lt;&lt;&quot;借书成功&quot;&lt;&lt;endl; return 1; } } int ReturnBook(int k) //还书 { int r; r=Search(k); if(r==0) { cout&lt;&lt;&quot;抱歉！不存在你要还的书。&quot;&lt;&lt;endl; return 0; } else { //cout&lt;&lt;&quot;归还成功。&quot;&lt;&lt;endl; return 0; } } int menu_selete() { int choose; system(&quot;cls&quot;); cout&lt;&lt;&quot;**********图书管理系统************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;1.新书入库\\t 2.查找书籍&quot;&lt;&lt;endl; cout&lt;&lt;&quot;3.显示库存\\t 4.借阅书籍&quot;&lt;&lt;endl; cout&lt;&lt;&quot;5.归还书籍\\t &quot;&lt;&lt;endl; cout&lt;&lt;&quot;7.退出系统&quot;&lt;&lt;endl; cout&lt;&lt;&quot;***********************************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;请输入你需要的操作（1~7）：&quot;; do { cin&gt;&gt;choose; }while(choose&lt;1||choose&gt;7); return choose; } int main() { int j; book k; read(); int i; while(1) { switch(menu_selete()) { case 1: system(&quot;cls&quot;); cout&lt;&lt;&quot;录入书信息：&quot;&lt;&lt;endl; clock_t start,stop; double duration; start=clock(); InBookMess(); stop=clock(); duration=((double)(stop-start))/CLOCKS_PER_SEC; printf(&quot;该程序运行时间是：%f\\n&quot;,duration); cout&lt;&lt;&quot;插入成功&quot;&lt;&lt;endl; cout&lt;&lt;&quot;录入结束。&quot;&lt;&lt;endl; cout&lt;&lt;&quot;当前书库的库存信息如下:&quot;&lt;&lt;endl; cout&lt;&lt;&quot;按任意键返回&quot;; getch(); break; case 2: system(&quot;cls&quot;); cout&lt;&lt;&quot;查找书信息：&quot;&lt;&lt;endl; cout&lt;&lt;&quot;请输入书号：&quot;; cin&gt;&gt;j; start=clock(); i = Search(j); if(j!=0) { cout&lt;&lt;&quot;书号&quot;&lt;&lt;b[j].key&lt;&lt;&quot;,书名为《&quot;&lt;&lt;b[j].name&lt;&lt;&quot;》，作者为&quot;&lt;&lt;b[j].author&lt;&lt;&quot;,现存&quot;&lt;&lt;b[j].stock&lt;&lt;&quot;本，总量&quot;&lt;&lt;b[j].total&lt;&lt;&quot;本。&quot;&lt;&lt;endl; //ShowBookMess(r.pt-&gt;key[r.i]); stop=clock(); duration=((double)(stop-start))/CLOCKS_PER_SEC; printf(&quot;该程序运行时间是：%f\\n&quot;,duration); } else { cout&lt;&lt;&quot;你要查找的书号&quot;&lt;&lt;k.key&lt;&lt;&quot;不存在！&quot;&lt;&lt;endl; cout&lt;&lt;&quot;查找结束&quot;&lt;&lt;endl; } cout&lt;&lt;&quot;按任意键返回&quot;; getch(); break; case 3: system(&quot;cls&quot;); cout&lt;&lt;&quot;-----------全部的书------------&quot;&lt;&lt;endl; Shownode(count_num); cout&lt;&lt;&quot;-----------显示完毕------------&quot;&lt;&lt;endl; cout&lt;&lt;&quot;按任意键返回&quot;; getch(); break; case 4: system(&quot;cls&quot;); cout&lt;&lt;&quot;借书：&quot;&lt;&lt;endl; cout&lt;&lt;&quot;请输入书号：&quot;; cin&gt;&gt;k.key; if(BorrowBook(j)) { cout&lt;&lt;&quot;借书成功。&quot;&lt;&lt;endl; } else cout&lt;&lt;&quot;借书失败。&quot;&lt;&lt;endl; cout&lt;&lt;&quot;按任意键返回&quot;; getch(); break; case 5: system(&quot;cls&quot;); cout&lt;&lt;&quot;还书：&quot;&lt;&lt;endl; cout&lt;&lt;&quot;请输入书号：&quot;; cin&gt;&gt;j; if(ReturnBook(j)) { cout&lt;&lt;&quot;还书成功。&quot;&lt;&lt;endl; } else cout&lt;&lt;&quot;还书失败。&quot;&lt;&lt;endl; cout&lt;&lt;&quot;按任意键返回&quot;; cout&lt;&lt;&quot;按任意键返回&quot;; getch(); break; case 7: // save(root); exit(0); } } }","categories":[],"tags":[]},{"title":"图书管理系统","slug":"B树图书管理系统","date":"2019-11-21T17:18:21.620Z","updated":"2019-12-07T14:23:07.533Z","comments":true,"path":"2019/11/22/B树图书管理系统/","link":"","permalink":"http://yoursite.com/2019/11/22/B%E6%A0%91%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"##图书管理系统 #include&lt;iostream&gt; #include&lt;string.h&gt; #include&lt;stdlib.h&gt; #include&lt;stdio.h&gt; #include&lt;conio.h&gt; #include&lt;time.h&gt; using namespace std; #define N 1000000 #define m 5 //B树的阶 struct book //书的结构体 { unsigned long long int key;//书号 char name[30]; //书名 char author[20];//作者 unsigned int stock; //现存量 unsigned int total;//总库存量 } b[N];//存储书的数组 typedef struct BTreeNode { int keynum;//结点关键值/关键码个数 struct BTreeNode *parent; //父结点指针 book key[m+1]; //一个结点中最多存放的书的个数，k[0]未用 struct BTreeNode *ptr[m+1]; //子树结点数组指针 }BTNode; BTNode *root=NULL; typedef struct //搜素结果的三元组定义 { BTNode *pt; //结点地址指针 int i; //结点中关键码序号 int tag; //tag=0不成功，tag=1成功 }Result; int Search(BTNode *p,book k) //在一个结点中查找元素，返回结点位置 { if(!p) return -1; int i=0; for(i=0; i&lt;p-&gt;keynum&amp;&amp;p-&gt;key[i+1].key&lt;=k.key; i++); return i; } Result SearchBTree(BTNode *T,book k) //在m阶B树上查找关键字K，返回结果（pt,i,tag） { BTNode *p,*q; int i; Result R; p=T; q=NULL; int found=0; i=0; while(p&amp;&amp;!found) { i=Search(p,k); if(i&gt;0&amp;&amp;p-&gt;key[i].key==k.key) found=1; else { q=p; p=p-&gt;ptr[i]; } } if(found) { R.pt=p; R.i=i; R.tag=1; //找到，成功 } else { R.pt=q; R.i=i; R.tag=0;//不成功 } return R; } void Copy(book &amp;b,book k) //复制一个结点 { b.key=k.key; strcpy(b.name,k.name); strcpy(b.author,k.author); b.stock=k.stock; b.total=k.total; } void Insert(BTNode* &amp;q,int i,book x,BTNode *ap) //插入一条记录 { int n=q-&gt;keynum; for(int j=n;j&gt;i;j--) { Copy(q-&gt;key[j+1],q-&gt;key[j]); q-&gt;ptr[j+1]=q-&gt;ptr[j]; } Copy(q-&gt;key[i+1],x); q-&gt;ptr[i+1]=ap; if(ap) ap-&gt;parent=q; q-&gt;keynum++; } void split(BTNode* &amp;q,int s,BTNode *&amp;ap) //分裂结点 { int i,j,n=q-&gt;keynum; ap=(BTNode*)malloc(sizeof(BTNode)); ap-&gt;ptr[0]=q-&gt;ptr[s]; for(i=s+1,j=1;i&lt;=n;i++,j++) { Copy(ap-&gt;key[j],q-&gt;key[i]); ap-&gt;ptr[j]=q-&gt;ptr[i]; } ap-&gt;keynum=n-s; ap-&gt;parent=q-&gt;parent; for(i=0;i&lt;=n-s;i++) { if(ap-&gt;ptr[i]) ap-&gt;ptr[i]-&gt;parent=ap; } q-&gt;keynum=s-1; } void NewRoot(BTNode* &amp;T,BTNode* p,book x,BTNode *ap) //生成一个新的树根结点 { T=(BTNode*)malloc(sizeof(BTNode)); T-&gt;keynum=1; //设置当前结点的元素个数 T-&gt;ptr[0]=p; //设置左边结点的树根 T-&gt;ptr[1]=ap; //设置右边的树根 Copy(T-&gt;key[1],x); //将x元素的结点值复制到T的第一个元素中 if(p) //当孩子不空时就设置当前结点为孩子的双亲 p-&gt;parent=T; if(ap) ap-&gt;parent=T; T-&gt;parent=NULL; //当前结点双亲为空 } void ShowBTNode(BTNode *p) //输出书的信息 { for(int i=1;i&lt;=p-&gt;keynum;i++) { cout&lt;&lt;&quot;书号&quot;&lt;&lt;p-&gt;key[i].key&lt;&lt;&quot;,书名为《&quot;&lt;&lt;p-&gt;key[i].name&lt;&lt;&quot;》，作者为&quot;&lt;&lt;p-&gt;key[i].author&lt;&lt;&quot;,现存&quot;&lt;&lt;p-&gt;key[i].stock&lt;&lt;&quot;本，总量&quot;&lt;&lt;p-&gt;key[i].total&lt;&lt;&quot;本。&quot;&lt;&lt;endl; } } void ShowBookMess(book bk) //显示书的信息，参数是book类型 { cout&lt;&lt;&quot;书号&quot;&lt;&lt;bk.key&lt;&lt;&quot;,书名为《&quot;&lt;&lt;bk.name&lt;&lt;&quot;》，作者为&quot;&lt;&lt;bk.author&lt;&lt;&quot;,现存&quot;&lt;&lt;bk.stock&lt;&lt;&quot;本，总量&quot;&lt;&lt;bk.total&lt;&lt;&quot;本。&quot;&lt;&lt;endl; } int InsertBTNode(BTNode *&amp;T,book k) //插入新书，在B树中插入新结点 //在m阶B树T上结点*q的key[i]与k[i+1]之间插入关键字k; { BTNode *ap; Result r; BTNode *q; int i; char addnum; int finished,needNewRoot,s; book x; if(!T) //root为NULL时，将book存储在根结点 { NewRoot(T,NULL,k,NULL); } else { r=SearchBTree(T,k); //查找元素k在树中的位置 q=r.pt; i=r.i; if(r.tag==1)//有相同的书号 { if(strcmp(q-&gt;key[i].name,k.name)!=0) //当书名不等时 { cout&lt;&lt;&quot;已存在书号为&quot;&lt;&lt;q-&gt;key[i].key&lt;&lt;&quot;的书，录入失败，请重新编号！&quot;&lt;&lt;endl; ShowBookMess(q-&gt;key[i]); return 0; } if(strcmp(q-&gt;key[i].name,k.name)==0) { cout&lt;&lt;&quot;该书已存在，是否增加其总存储量（y/n）:&quot;; cin&gt;&gt;addnum; if(addnum==&apos;Y&apos;||addnum==&apos;y&apos;) { q-&gt;key[i].total+=k.total; q-&gt;key[i].stock+=k.stock; cout&lt;&lt;&quot;增加总量后书的信息如下:&quot;&lt;&lt;endl; } else { cout&lt;&lt;&quot;该书的信息如下：&quot;&lt;&lt;endl; } ShowBookMess(q-&gt;key[i]); return 0; } } x=k; //没有相同的书号时，插入 ap=NULL; finished=needNewRoot=0; while(!needNewRoot&amp;&amp;!finished) { Insert(q,i,x,ap); //插入结点 if(q-&gt;keynum&lt;m) finished=1; //插入完成 else { //分裂结点*q s=(m+1)/2; split(q,s,ap); x=q-&gt;key[s]; if(q-&gt;parent) //在双亲结点*q中查找x的插入位置 { q=q-&gt;parent; i=Search(q,x); } else { needNewRoot=1; } } } if(needNewRoot) NewRoot(T,q,x,ap); //生成新根结点*T,q和ap为子树指针 } return 1; } void InBookMess(book &amp;bk) //输入书的信息 { cout&lt;&lt;&quot;请输入书号：&quot;;cin&gt;&gt;bk.key; cout&lt;&lt;&quot;请输入书名：&quot;;cin&gt;&gt;bk.name; cout&lt;&lt;&quot;请输入作者：&quot;;cin&gt;&gt;bk.author; cout&lt;&lt;&quot;请输入总量：&quot;;cin&gt;&gt;bk.total; bk.stock=bk.total; } void display(BTNode *T) //显示整棵树的信息 { int i=0; if(T) { ShowBTNode(T); //显示该结点的全部值 for(i=0;i&lt;=T-&gt;keynum;i++)//递归显示每个结点 { if(T-&gt;ptr[i]) display(T-&gt;ptr[i]); } } } int BorrowBook(BTNode *T,book k) //借书 { Result r=SearchBTree(T,k); if(r.tag==0) { cout&lt;&lt;&quot;你要借阅的书不存在。&quot;&lt;&lt;endl; return 0; } if(r.pt-&gt;key[r.i].stock&lt;1) { cout&lt;&lt;&quot;你要借阅的书已经借完。&quot;&lt;&lt;endl; return 0; } r.pt-&gt;key[r.i].stock--; return 1; } int ReturnBook(BTNode *T,book k) //还书 { //int number; Result r=SearchBTree(T,k); if(r.tag==0) { cout&lt;&lt;&quot;抱歉！不存在你要还的书。&quot;&lt;&lt;endl; return 0; } if(r.pt-&gt;key[r.i].stock&gt;=r.pt-&gt;key[r.i].total) { cout&lt;&lt;&quot;该书无借出。&quot;&lt;&lt;endl; return 0; } else r.pt-&gt;key[r.i].stock++; } void save(BTNode *p) //保存文件 { FILE *fp; if((fp=fopen(&quot;com.txt&quot;,&quot;wb&quot;))==NULL) { cout&lt;&lt;&quot;创建文件失败！&quot;&lt;&lt;endl; getch(); return; } for(int i=1;i&lt;=2;i++) { fprintf(fp,&quot;%d %s %s %d %d \\n&quot;,p-&gt;key[i].key,p-&gt;key[i].name,p-&gt;key[i].author,p-&gt;key[i].stock,p-&gt;key[i].total); } fclose(fp); } void read() //读取文件 { FILE *fp,fp1; if((fp=fopen(&quot;com.txt&quot;,&quot;rb&quot;))==NULL) { cout&lt;&lt;&quot;读取文件失败！&quot;&lt;&lt;endl; getchar(); return; } for(int i=1;;i++) { if(fscanf(fp,&quot;%d%s%s%d%d&quot;,&amp;b[i].key,&amp;b[i].name,&amp;b[i].author,&amp;b[i].stock,&amp;b[i].total)==EOF) { break; } InsertBTNode(root,b[i]); } fclose(fp); } void output(BTNode* T,int n) //凹入法输出这课树 { int i; if(T==NULL) return; /*if(n!=1) { for(i=1;i&lt;n;i++) cout&lt;&lt;&quot;----&quot;; }*/ for(int j=1;j&lt;=T-&gt;keynum;j++) { cout&lt;&lt;T-&gt;key[j].key&lt;&lt;endl; cout&lt;&lt;&quot;----&quot;; } for(i=0;i&lt;=T-&gt;keynum;i++) { if(T-&gt;ptr[i]) output(T-&gt;ptr[i],n++); } } int menu_selete() { int choose; system(&quot;cls&quot;); cout&lt;&lt;&quot;**********图书管理系统************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;1.新书入库\\t 2.查找书籍&quot;&lt;&lt;endl; cout&lt;&lt;&quot;3.显示库存\\t 4.借阅书籍&quot;&lt;&lt;endl; cout&lt;&lt;&quot;5.归还书籍\\t &quot;&lt;&lt;endl; cout&lt;&lt;&quot;7.退出系统&quot;&lt;&lt;endl; cout&lt;&lt;&quot;***********************************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;请输入你需要的操作（1~7）：&quot;; do { cin&gt;&gt;choose; }while(choose&lt;1||choose&gt;7); return choose; } int main() { book k; Result r; read(); while(1) { switch(menu_selete()) { case 1: system(&quot;cls&quot;); cout&lt;&lt;&quot;录入书信息：&quot;&lt;&lt;endl; InBookMess(k); InsertBTNode(root,k); cout&lt;&lt;&quot;录入结束。&quot;&lt;&lt;endl; save(root); cout&lt;&lt;&quot;当前书库的库存信息如下:&quot;&lt;&lt;endl; display(root); cout&lt;&lt;&quot;按任意键返回&quot;; getch(); break; case 2: system(&quot;cls&quot;); cout&lt;&lt;&quot;查找书信息：&quot;&lt;&lt;endl; cout&lt;&lt;&quot;请输入书号：&quot;; cin&gt;&gt;k.key; clock_t start,stop; double duration; start=clock(); r=SearchBTree(root,k); stop=clock(); duration=((double)(stop-start))/CLOCKS_PER_SEC; printf(&quot;该程序运行时间是：%f\\n&quot;,duration); if(r.tag==1) { ShowBookMess(r.pt-&gt;key[r.i]); } else cout&lt;&lt;&quot;你要查找的书号&quot;&lt;&lt;k.key&lt;&lt;&quot;不存在！&quot;&lt;&lt;endl; cout&lt;&lt;&quot;查找结束&quot;&lt;&lt;endl; cout&lt;&lt;&quot;按任意键返回&quot;; getch(); break; case 3: system(&quot;cls&quot;); cout&lt;&lt;&quot;-----------全部的书------------&quot;&lt;&lt;endl; display(root); cout&lt;&lt;&quot;-----------显示完毕------------&quot;&lt;&lt;endl; cout&lt;&lt;&quot;按任意键返回&quot;; getch(); break; case 4: system(&quot;cls&quot;); cout&lt;&lt;&quot;借书：&quot;&lt;&lt;endl; cout&lt;&lt;&quot;请输入书号：&quot;; cin&gt;&gt;k.key; if(BorrowBook(root,k)) { cout&lt;&lt;&quot;借书成功。&quot;&lt;&lt;endl; } else cout&lt;&lt;&quot;借书失败。&quot;&lt;&lt;endl; cout&lt;&lt;&quot;按任意键返回&quot;; getch(); break; case 5: system(&quot;cls&quot;); cout&lt;&lt;&quot;还书：&quot;&lt;&lt;endl; cout&lt;&lt;&quot;请输入书号：&quot;; cin&gt;&gt;k.key; if(ReturnBook(root,k)) { cout&lt;&lt;&quot;归还成功。&quot;&lt;&lt;endl; } else cout&lt;&lt;&quot;归还失败。&quot;&lt;&lt;endl; cout&lt;&lt;&quot;按任意键返回&quot;; getch(); break; case 6: system(&quot;cls&quot;); cout&lt;&lt;&quot;凹入法显示树：&quot;&lt;&lt;endl; output(root,1); cout&lt;&lt;&quot;按任意键返回&quot;; getch(); break; case 7: save(root); exit(0); } } }","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-11-08T14:04:30.465Z","updated":"2019-11-08T14:04:30.465Z","comments":true,"path":"2019/11/08/hello-world/","link":"","permalink":"http://yoursite.com/2019/11/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}